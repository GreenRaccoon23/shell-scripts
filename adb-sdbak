#!/bin/bash
shopt -s extglob

declare -r CMD_PULL="adb-pull";
declare -r CMD_RM="gvfs-trash";

declare -r SCRIPT_PATH="$0";
declare -r SCRIPT_NAME="${SCRIPT_PATH##*/}";

declare -r SCRIPT_DIR="$(dirname "$0")";

declare -r TMP_DB="${SCRIPT_DIR}/.${SCRIPT_NAME}.tmp.db";

declare -r TMP_FILE_DIRS="${SCRIPT_DIR}/.${SCRIPT_NAME}_dirs.tmp";

# Set bool options.
declare DO_FORCE;

# Set string options.
declare SRC;
declare DST;
SRC="/sdcard";
DST="${HOME}/tmp/$(basename ${SRC})_$(date +%Y-%m-%d)";

declare -a DIRS;
declare SIZE_TOTAL=0;
declare SIZE_DONE=0;

# Print help and exit.
_help() {
    local bin="${HOME}/bin"
    local fmt;
    fmt="$(date +%Y-%m-%d)";
    cat << EOH >&2
${SCRIPT_NAME}
DESCRIPTION:
  Pull an Android devices ${SRC} contents to ${DST}.
USAGE:
  ${SCRIPT_NAME} [OPTIONS] [<remote-file-to-pull>] [<local-directory-to-save>]
OPTIONS:
  r, resume, c, continue [default]
    Resume a backup operation if one did not complete earlier.
    Useful when you need to cancel this tool and resume it later
    or when it previously was cancelled by accident.
  a, all, f, force, full
    Force redo a a full backup, even if a previous one did not complete.
    CAUTION: Any existing files will be overwritten.
DEFAULT:
  ${SCRIPT_NAME} -r ${SRC} ${DST}
NOTE:
  Requires that the Bash script "${CMD_PULL}" is in the '\$PATH'.
  (E.g., place "${SCRIPT_NAME}" in "${HOME}/bin/" and 
    add 'export PATH=\$PATH:\$HOME/bin' to '~/.bashrc'.)
EOH

    [ -n "${1}" ] &&
        exit "${1}";
    exit 1;
};

# Analyze user arguments.
_getopts() {
    # Declare arrays for commandline bool switches and string options.
    local -a Bools;
    local -a Strings;

    # Iterate over user arguments.
    local -i i;
    local flag;
    for ((i=1; i<=$#; i++)); do
        eval flag="\$$i";
        case "${flag}" in 
            *(-)[hH]*([eE][lL][pP]) )
                _help;
                ;;
            *(-)[rR]*([eE][sS][uU][mM][eE]) )
                Bools[0]=0;
                ;;
            *(-)[cC]*([oO][nN][tT][iI][nN][uU][eE]) )
                Bools[0]=0;
                ;;
            *(-)[aA]*([lL]) )
                Bools[1]=0;
                ;;
            *(-)[fF]*([uU]+([lL])) )
                Bools[1]=0;
                ;;
            *(-)[fF]*([oO][rR][cC][eE]) )
                Bools[1]=0;
                ;;
            * )
                Strings+=( "${flag}" );
                ;;
        esac;
    done;
    
    # Set bool options.
    DO_FORCE="${Bools[1]}";
    if [ -n "${DO_FORCE}" ]; then
        [ -e "${TMP_DB}" ] && "${CMD_RM}" "${TMP_DB}";
        [ -e "${TMP_FILE_DIRS}" ] && "${CMD_RM}" "${TMP_FILE_DIRS}";
    fi;

    # Set string options.
    [ -n "${Strings[0]}" ] &&
        SRC="$(_fmtDir "${Strings[0]}")";
    [ -n "${Strings[1]}" ] &&
        DST="$(_fmtDir "${Strings[1]}")";
    mkdir -p "${DST}";
};

# Set console color.
# Optionally, run a command afterwards, and once the command returns,
#   reset the console color to normal.
_c() {
    local -A Codes=( 
        ["black"]="0" 
        ["red"]="1" 
        ["green"]="2" 
        ["yellow"]="3" 
        ["blue"]="4" 
        ["magenta"]="5" 
        ["cyan"]="6" 
        ["white"]="7" 
        ["bk"]="0" 
        ["r"]="1" 
        ["g"]="2" 
        ["y"]="3" 
        ["bu"]="4" 
        ["m"]="5" 
        ["c"]="6" 
        ["w"]="7" 
    );

    local k c;
    for k in "${!Codes[@]}"; do
        [ "${k}" = "${1}" ] &&
            c="${Codes[$k]}";
    done;

    [ -n "${c}" ] &&
        tput setaf "${c}";
    
    [ -z "${*:2}" ] &&
        return;
    eval "${@:2}";
    tput sgr0;
};

# Set the console color to bold.
# Optionally, pass any arguments to function '_c'.
_C() {
    tput bold;
    [ -n "$*" ] &&
        _c "$@";
};

# Reset console color to normal.
_u() {
    tput sgr0;
};

# Echo a command, and then evaluate it.
_evalcho() {
    echo "$@";
    eval "$@";
};

# Exit with status 1 after echoing an error message.
_err() {
    local err="$*";
    [ -z "${err}" ] &&
        err="An error occurred. Cannot continue.";

    _c red;
    echo -e "${err}";
    _u;
    exit 1;
};

# Run a command silently.
_q() {
    eval "$@" >&/dev/null;
};

# Ask user to answer a "yes or no" question.
# Analyse the user's answer, with NO as the default.
_yN() {
    local -i t="${1}";
    local ans;

    if [ "${t}" != 0 ]; then
        read -t "${t}" -p "${*:2} [y/N]: " ans;
    else
        read -p "$* [y/N]: " ans;
    fi;

    [ -z "${ans}" ] && echo;

    case "${ans}" in [yY] | [yY][eE][sS])
        return 0;
    esac;
    return 1;
};

# Ask user to answer a "yes or no" question.
# Analyse the user's answer, with YES as the default.
_Yn() {
    local -i t="${1}";
    local ans;

    if [ "${t}" = 0 ]; then
        read -p "$* [Y/n]: " ans;
    else
        read -t "${t}" -p "${*:2} [Y/n]: " ans;
    fi;

    [ -z "${ans}" ] && echo;

    case "${ans}" in [nN] | [nN][oO])
        return 1;
    esac;
    return 0;
};

# Wait for Android device to connect.
_connect() {
    local connected;
    connected="$(adb devices | head -2 | tail -1)";
    if [ "${connected}" ]; then
        return 0;
    fi;
    echo "Waiting for Android device to connect...";
    adb wait-for-device;
};

# Remove a trailing '/' from a string if it exists.
_fmtDir() {
    local d="$*";
    if [ "${d: -1}" = "/" ]; then
        echo "${d:: -1}";
    else
        echo "${d}";
    fi;
};

_init() {

    _getopts "$@";

    _connect || exit $?;

    _dbCreate;
};

_main() {

    _dbPopulate || exit $?;

    _c green "echo Counting total size of directories...";
    _setSizeTotal || exit $?;

    _c green "echo Counting total size of any pulled directories...";
    _setSizeDone || exit $?;

    # _choose; #todo: do this?

    _c green "echo Fetching list of directories to pull...";
    _fetchDirs;

    _q pushd "${DST}";
    _c green "echo Starting backup";
    _backup;
    _q popd;

    _cleanUp;

    echo "${DST}";
};

_dbCreate() {

    [ -e "${TMP_DB}" ] && _dbTablesExist && return 0;

    _c green "echo Creating database...";

    local query="
        CREATE TABLE dirs (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name VARCHAR(255) NOT NULL DEFAULT '',
            size BIGINT NOT NULL DEFAULT 0,
            pull TINYINT NOT NULL DEFAULT 1,
            pulled TINYINT NOT NULL DEFAULT 0,
            skipped TINYINT NOT NULL DEFAULT 0,
            sort MEDIUMINT NOT NULL DEFAULT 1,

            UNIQUE (name) ON CONFLICT REPLACE
        )
    ;";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to create database.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";
};

_dbTablesExist() {

    local name;
    local query="SELECT name FROM sqlite_master WHERE type='table' AND name='dirs' LIMIT 1;";

    name="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to check if tables exist in TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    [ -z "${name}" ] && return 1;
    return 0;
};

_dbPopulate() {

    _dirsPopulated && return 0;

    _retrieveDirs;
    _setDirs;
    _dbInsertDirs;

    _retrieveAndUpdateSizes;
};

_dirsPopulated() {

    local count;
    local query="SELECT COUNT(id) FROM dirs LIMIT 1;";

    count="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to check if tables are populated in TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    [ "${count}" = "0" ] && return 1;
    return 0;
};

# Store the target directories into an array
# and save them in a temporary file.
_retrieveDirs() {

    [ -e "${TMP_FILE_DIRS}" ] && return 0;

    _c green "echo Retrieving directories...";

    echo " " adb shell \"su -c /su/xbin/ls --color=never -A1 ${SRC}/\" '>' \"${TMP_FILE_DIRS}\";
    adb shell "su -c /su/xbin/ls --color=never -A1 ${SRC}/" > "${TMP_FILE_DIRS}";
};

_setDirs() {

    [ ! -e "${TMP_FILE_DIRS}" ] && _err "Code err! TMP_FILE_DIRS does not exist.\n  TMP_FILE_DIRS: '${TMP_FILE_DIRS}'";

    IFS=$'\r\n' read -d '' -r -a DIRS < "${TMP_FILE_DIRS}";
    [ -z "${DIRS[*]}" ] && _err "Failed to populate DIRS array from TMP_FILE_DIRS.\n  TMP_FILE_DIRS: '${TMP_FILE_DIRS}'";
};

_dbInsertDirs() {

    _c green "echo Inserting directories into database...";

    local name;
    local query;

    for name in "${DIRS[@]}"; do
        query="INSERT INTO dirs (name) VALUES ('${name}');";
        sqlite3 "${TMP_DB}" "${query}";
        [ $? -ne 0 ] && _err "Failed to insert name into dirs table of TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  name: '${name}'\n  query: '${query}'";
    done;
};

_retrieveAndUpdateSizes() {

    [ -z "${DIRS}" ] && _err "Code err! DIRS array is empty.\n  DIRS: '${DIRS}'";

    local name;
    local -i size;

    _c green "echo Retrieving directory sizes...";

    for name in "${DIRS[@]}"; do
        # _adbDirSize "${name}"; continue; #delete
        size="$(_adbDirSize "${name}")";
        if [ -z "${size}" ]; then
            _c yellow "echo Failed to get size of \"${name}\"";
            size=0;
        fi;

        _dbUpdateSize "${name}" "${size}";
    done;
    # exit; #delete
};

_adbDirSize() {

    local name="/sdcard/${1}";

    local tab;
    tab="$(echo -e "\t")";

    local info;
    local statuss;
    local size;

    # info="$(adb shell "du -ack \"${name}\"; printf $?")";
    info="$(adb shell "du -sck \"${name}\"; printf $?")";

    statuss="$(echo "${info}" | tail -n 1)"; # last line: '0'
    if [ "${statuss}" != "0" ]; then
        echo "0"; # todo: right way to handle this?
        return;
    fi;

    info="$(echo "${info}" | tail -n 2 | head -n 1)"; # second to last line: '12345678  total'

    # trim the whitespace and letters which follow the byte total
    size="${info%% *}";
    size="${size%%$tab*}";

    echo "${size}";
};

_dbUpdateSize() {

    local name="${1}";
    local size="${2}";
    local query="UPDATE dirs SET size = ${size} WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to update size in TMP_DB.\n  name: '${name}'\n  size: '${size}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_setSizeTotal() {

    local query="SELECT SUM(size) FROM dirs;";

    SIZE_TOTAL="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to get size total from TMP_DB.\n  SIZE_TOTAL: '${SIZE_TOTAL}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";
    [ -z "${SIZE_TOTAL}" ] && _err "Failed to get size total from TMP_DB.\n  SIZE_TOTAL: '${SIZE_TOTAL}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_setSizeDone() {

    local query="SELECT SUM(size) FROM dirs WHERE pulled = 1 OR pull = 0;";

    SIZE_DONE="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to get size done from TMP_DB.\n  SIZE_DONE: '${SIZE_DONE}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    [ -z "${SIZE_DONE}" ] && SIZE_DONE=0;

    return 0;
};

_fetchDirs() {

    local query="SELECT name FROM dirs WHERE pulled = 0 AND pull = 1 ORDER BY sort ASC;";

    IFS=$'\r\n' read -d '' -r -a DIRS < <(sqlite3 "${TMP_DB}" "${query}");
    [ -z "${DIRS[*]}" ] && _err "Failed to populate DIRS array from TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";
};

# Pull each file from the device.
_backup() {
    local name;
    for name in "${DIRS[@]}"; do
        _pull "${name}";
        _c blue "echo Progress: ${SIZE_DONE} KB / ${SIZE_TOTAL} KB $(_percentDone)%";
    done;
};

_pull() {

    local name="${*}";

    if _c green "echo -n ==\> Pull \\\"${name}\\\"?" && _Yn 3; then #yes
        "${CMD_PULL}" "${SRC}/${name}" &&
            _pulled "${name}" &&
            _updateSizeDone "${name}";

    elif _c green "echo -n ==\> Remove \\\"${name}\\\" from backup list?" && _yN 30; then #yes
        _disable "${name}" &&
            _updateSizeDone "${name}";

    else
        _skipped "${name}";
            _updateSizeDone "${name}";

    fi;

    return $?;
};

_pulled() {

    local name="${1}";
    local query="UPDATE dirs SET pulled = 1 WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as pulled in TMP_DB.\n  name: '${name}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_skipped() {

    local name="${1}";
    local query="UPDATE dirs SET skipped = 1, sort = 0 WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as skipped in TMP_DB.\n  name: '${name}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_disable() {

    local name="${1}";
    local query="UPDATE dirs SET pull = 0 WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as not to be pulled in TMP_DB.\n  name: '${name}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_updateSizeDone() {

    local name="${1}";
    local query="SELECT size FROM dirs WHERE name = '${name}';";
    local size;

    size="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to get size from TMP_DB.\n  name: '${name}'\n  size: '${size}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    SIZE_DONE=$((SIZE_DONE + size));
};

_percentDone() {

    local decimal;
    local percent;

    if [ -z "${SIZE_DONE}" ]; then
        echo "00.00";
    elif [ "${SIZE_DONE}" = "${SIZE_TOTAL}" ]; then
        echo "100.00";
    else
        decimal=$(bc <<< "scale=4; ${SIZE_DONE}/${SIZE_TOTAL}");
        percent=$(bc <<< "scale=4; ${decimal}*100");
        # echo $percent; #delete

        # yeah, this is nonsense. good luck
        if [ "${percent}" = "0" ]; then
            echo "00.00";

        elif [ "${percent:0:1}" = "." ]; then
            echo "00.${percent:1:2}";

        elif [ "${percent:1:1}" = "." ]; then
            echo "0${percent:0:1}.${percent:2:2}";

        elif [ "${percent:2:1}" = "." ]; then
            echo "${percent:0:2}.${percent:3:2}";

        else
            echo "${percent:1:2}.${percent:3:4}";
        fi;
    fi;
}

# Manage temporary files and report any final errors.
_cleanUp() {

    [-e "${TMP_FILE_DIRS}" ] && "${CMD_RM}" "${TMP_FILE_DIRS}";

    echo;
    echo "Did not pull:";
    _fetchNonPulled;

    if (_c green "echo -n ==\> Pull them now?" && _yN 10); then #yes
        "$0";
        exit $?;
    fi;

    if (_c green "echo -n ==\> Remember to pull these files the next time this script is run?" && _Yn 10); then #yes
        return 0;
    else
        [-e "${TMP_DB}" ] && "${CMD_RM}" "${TMP_DB}";
    fi;
};

_fetchNonPulled() {

    local query="SELECT name FROM dirs WHERE pulled = 0;";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to fetch non-pulled rows from TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_init "$@";
_main || exit $?;
