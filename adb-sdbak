#!/bin/bash
shopt -s extglob

declare -r CMD_PULL="adb-pull";
declare -r CMD_RM="gvfs-trash";
declare -r BUSYBOX="/su/xbin";

declare -r ME="$0";
declare -r MY_NAME="${ME##*/}";
declare -r MY_DIR="${ME%/*}";

declare -r TMP_DB="${MY_DIR}/.${MY_NAME}.tmp.db";
declare -r TMP_FILE_DIRS="${MY_DIR}/.${MY_NAME}_dirs.tmp";

declare -r TABLE_SRC_DIRS="src_dirs";
declare -r TABLE_SRC_DIRS_SCHEMA="
    CREATE TABLE ${TABLE_SRC_DIRS} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name VARCHAR(255) NOT NULL DEFAULT '',
        size BIGINT NOT NULL DEFAULT 0,
        pull TINYINT NOT NULL DEFAULT 1,
        pulled TINYINT NOT NULL DEFAULT 0,
        skipped TINYINT NOT NULL DEFAULT 0,
        sort MEDIUMINT NOT NULL DEFAULT 1,

        UNIQUE (name) ON CONFLICT REPLACE
    )
;";

# Set bool options.
declare DO_FORCE;

# Set string options.
declare SRC_PARENT;
declare DST_PARENT;
SRC_PARENT="/sdcard";
DST_PARENT="${HOME}/tmp/$(basename ${SRC_PARENT})_$(date +%Y-%m-%d)";

declare -a SRC_INFOS;
declare -A SRC_IDS_AVAILABLE;
declare -a SRC_NAMES;
declare SRC_SIZE_TOTAL=0;
declare SRC_SIZE_PULLED=0;

declare SELECTION;

# Print help and exit.
_help() {
    cat << EOH >&2
${MY_NAME}
DESCRIPTION:
  Pull ${SRC_PARENT} contents from an Android device.
USAGE:
  ${MY_NAME} [OPTIONS] [<remote-file-to-pull>] [<local-directory-to-save>]
OPTIONS:
  r, resume, c, continue [default]
    Resume a backup operation if one did not complete earlier.
    Useful when you need to cancel this tool and resume it later
    or when it previously was cancelled by accident.
  a, all, f, force, full
    Force redo a a full backup, even if a previous one did not complete.
    CAUTION: Any existing files will be overwritten.
DEFAULT:
  ${MY_NAME} -r ${SRC_PARENT} ${DST_PARENT}
NOTE:
  Requires that the Bash script "${CMD_PULL}" is in the '\$PATH'.
  (E.g., place "${MY_NAME}" in "${MY_DIR}" and
    add 'export PATH=\$PATH:${MY_DIR}' to '~/.bashrc'.)
EOH

    exit 0;
};

# Analyze user arguments.
_getopts() {
    # Declare arrays for commandline bool switches and string options.
    local -a Bools;
    local -a Strings;

    # Iterate over user arguments.
    local -i i;
    local flag;
    for ((i=1; i<=$#; i++)); do
        eval flag="\$$i";
        case "${flag}" in
            *(-)[hH]*([eE][lL][pP]) ) _help; ;;
            *(-)[rR]*([eE][sS][uU][mM][eE]) ) Bools[0]=0; ;;
            *(-)[cC]*([oO][nN][tT][iI][nN][uU][eE]) ) Bools[0]=0; ;;
            *(-)[aA]*([lL]) ) Bools[1]=0; ;;
            *(-)[fF]*([uU]+([lL])) ) Bools[1]=0; ;;
            *(-)[fF]*([oO][rR][cC][eE]) ) Bools[1]=0; ;;
            * ) Strings+=("${flag}"); ;;
        esac;
    done;

    # Set bool options.
    DO_FORCE="${Bools[1]}";

    # Set string options.
    [ -n "${Strings[0]}" ] && SRC_PARENT="$(_trimEndSlash "${Strings[0]}")";
    [ -n "${Strings[1]}" ] && DST_PARENT="$(_trimEndSlash "${Strings[1]}")";
};

_init() {

    _getopts "$@";

    _connect || exit $?;

    [ -n "${DO_FORCE}" ] && _rmTmpFiles;
    _dstCreate;
    _dbCreate;
};

# Wait for Android device to connect.
_connect() {
    local connected;
    connected="$(adb devices | head -2 | tail -1)";
    if [ "${connected}" ]; then
        return 0;
    fi;
    echo "Waiting for Android device to connect...";
    adb wait-for-device;
};

_rmTmpFiles() {

    _c green "echo Removing temporary files...";

    [ -e "${TMP_DB}" ] && "${CMD_RM}" "${TMP_DB}";
    [ -e "${TMP_FILE_DIRS}" ] && "${CMD_RM}" "${TMP_FILE_DIRS}";
};

_dstCreate() {

    _c green "echo Creating destination directory \\'${DST_PARENT}\\'...";

    mkdir -p "${DST_PARENT}";
};

_dbCreate() {

    [ -e "${TMP_DB}" ] && _dbTableExists && return 0;

    _c green "echo Creating database...";

    local query="${TABLE_SRC_DIRS_SCHEMA}";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to create database.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";
};

_dbTableExists() {

    local name;
    local query="SELECT name FROM sqlite_master WHERE type='table' AND name='${TABLE_SRC_DIRS}' LIMIT 1;";

    name="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to check if tables exist in TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    [ -z "${name}" ] && return 1;
    return 0;
};

_main() {

    _dbPopulate || exit $?;

    _showSrcDirs || exit $?;
    _selectSrcDirs || exit $?;

    _c green "echo Counting total size of directories...";
    _setSrcSizeTotal || exit $?;

    _c green "echo Counting total size of any pulled directories...";
    _setSrcSizePulled || exit $?;

    # _choose; #todo: do this?

    _c green "echo Fetching list of directories to pull...";
    _dbFetchNames;

    _q pushd "${DST_PARENT}";
    _c green "echo Starting backup";
    _pullDirs;
    _q popd;

    _cleanUp;

    echo "${DST_PARENT}";
};

_dbPopulate() {

    _dbPopulated && return 0;

    _pullAndInsertNames;
    _pullAndUpdateSizes;
};

_dbPopulated() {

    local count;
    local query="SELECT COUNT(id) FROM ${TABLE_SRC_DIRS} LIMIT 1;";

    count="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to check if tables are populated in TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    [ "${count}" = "0" ] && return 1;
    return 0;
};

_pullAndInsertNames() {

    _pullNames;
    _setSrcNames;
    _dbInsertNames;
};

# Store the target directories into an array
# and save them in a temporary file.
_pullNames() {

    [ -e "${TMP_FILE_DIRS}" ] && return 0;

    _c green "echo Retrieving directories...";

    echo " " adb shell \"su -c ${BUSYBOX}/ls --color=never -A1 ${SRC_PARENT}/\" '>' \"${TMP_FILE_DIRS}\";
    adb shell "su -c ${BUSYBOX}/ls --color=never -A1 ${SRC_PARENT}/" > "${TMP_FILE_DIRS}";
};

_setSrcNames() {

    [ ! -e "${TMP_FILE_DIRS}" ] && _err "Code err! TMP_FILE_DIRS does not exist.\n  TMP_FILE_DIRS: '${TMP_FILE_DIRS}'";

    IFS=$'\r\n' read -d '' -r -a SRC_NAMES < "${TMP_FILE_DIRS}";
    [ -z "${SRC_NAMES[*]}" ] && _err "Failed to populate SRC_NAMES array from TMP_FILE_DIRS.\n  TMP_FILE_DIRS: '${TMP_FILE_DIRS}'";
};

_dbInsertNames() {

    _c green "echo Inserting directories into database...";

    local name;
    local query;

    for name in "${SRC_NAMES[@]}"; do
        query="INSERT INTO ${TABLE_SRC_DIRS} (name) VALUES ('${name}');";
        sqlite3 "${TMP_DB}" "${query}";
        [ $? -ne 0 ] && _err "Failed to insert name into ${TABLE_SRC_DIRS} table of TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  name: '${name}'\n  query: '${query}'";
    done;
};

_pullAndUpdateSizes() {

    [ -z "${SRC_NAMES}" ] && _err "Code err! SRC_NAMES array is empty.\n  SRC_NAMES: '${SRC_NAMES}'";

    local name;
    local -i size;

    _c green "echo Retrieving directory sizes...";

    for name in "${SRC_NAMES[@]}"; do
        # _adbDirSize "${name}"; continue; #delete
        size="$(_adbDirSize "${name}")";
        if [ -z "${size}" ]; then
            _c yellow "echo Failed to get size of \"${name}\"";
            size=0;
        fi;

        _dbUpdateSize "${name}" "${size}";
    done;
    # exit; #delete
};

_adbDirSize() {

    local name="/${SRC_PARENT}/${1}";

    local tab;
    tab="$(echo -e "\t")";

    local info;
    local statuss;
    local size;

    info="$(adb shell "du -sck \"${name}\"; printf $?")";

    statuss="$(echo "${info}" | tail -n 1)"; # last line: '0'
    if [ "${statuss}" != "0" ]; then
        echo "0"; # todo: right way to handle this?
        return;
    fi;

    info="$(echo "${info}" | tail -n 2 | head -n 1)"; # second to last line: '12345678  total'

    # trim the whitespace and letters which follow the byte total
    size="${info%% *}";
    size="${size%%$tab*}";

    echo "${size}";
};

_dbUpdateSize() {

    local name="${1}";
    local size="${2}";
    local query="UPDATE ${TABLE_SRC_DIRS} SET size = ${size} WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to update size in TMP_DB.\n  name: '${name}'\n  size: '${size}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_showSrcDirs() {

    _dbFetchInfos;
    _printInfos;
};

_dbFetchInfos() {

    local query="SELECT id, size, name FROM ${TABLE_SRC_DIRS} WHERE pulled = 0 AND pull = 1 ORDER BY sort ASC;";

    IFS=$'\r\n' read -d '' -r -a SRC_INFOS < <(sqlite3 -header "${TMP_DB}" "${query}");
    # [ -z "${SRC_INFOS[*]}" ] && _err "Failed to populate SRC_INFOS array from TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'\n  SRC_INFOS: '${SRC_INFOS[*]}'";
    [ -z "${SRC_INFOS[*]}" ] && _err "All directories have been pulled already.";
};

_printInfos() {

    local widthCellIdd=5;
    local widthCellSize=10;

    local separator;
    separator=$(printf '%0.1s' " "{1..1000});

    local row;
    local -a cells;
    local idd;
    local size;
    local name;
    local spacing;

    _c green "echo Directories to be pulled:";

    for row in "${SRC_INFOS[@]}"; do

        IFS='|' read -ra cells <<< "${row}";
        idd="${cells[0]}";
        size="${cells[1]}";
        name="${cells[2]}";

        idd="[${idd}]";

        printf '    ';

        spacing=$((widthCellIdd - ${#idd}));
        printf '%s' "${idd}";
        printf '%*.*s' 0 "${spacing}" "${separator}";

        spacing=$((widthCellSize - ${#size}));
        printf '%s' "${size}";
        printf '%*.*s' 0 "${spacing}" "${separator}";

        printf '%s\n' "${name}";
    done;
};

_selectSrcDirs() {

    read -p "Enter a selection (default=all): " SELECTION;

    [ -z "${SELECTION}" ] && return 0;

    _enableSelection;

    return $?;
};

_enableSelection() {

    _setSrcIdsAvailable;
    _dbDisableAll || exit $?;

    local -a selectionGroups;
    IFS=',' read -ra selectionGroups <<< "${SELECTION}";

    local group;
    local -a range;
    local min;
    local max;
    local -i idd;

    for group in "${selectionGroups[@]}"; do

        IFS='-' read -ra range <<< "${group}";
        min="${range[0]}";
        max="${range[1]}";
        [ -z "${max}" ] && max="${min}";

        for idd in $(seq ${min} ${max}); do
            [ -z "${SRC_IDS_AVAILABLE[$idd]}" ] && continue;
            # echo "    idd: ${idd}";
            _dbEnable "${idd}";
        done;

    done;

    return $?;
};

# Make a hash table of id's which have not been disabled in the database.
_setSrcIdsAvailable() {

    local row;
    local -a cells;
    local idd;

    for row in "${SRC_INFOS[@]}"; do
        IFS='|' read -ra cells <<< "${row}";
        idd="${cells[0]}";
        SRC_IDS_AVAILABLE["${idd}"]=1;
    done;
};

_dbDisableAll() {

    local query="UPDATE ${TABLE_SRC_DIRS} SET pull = 0;";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark all rows as not to be pulled in TMP_DB.\n  '\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_dbEnable() {

    local idd="${1}";
    local query="UPDATE ${TABLE_SRC_DIRS} SET pull = 1 WHERE id = '${idd}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as to be pulled in TMP_DB.\n  idd: '${idd}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_setSrcSizeTotal() {

    local query="SELECT SUM(size) FROM ${TABLE_SRC_DIRS} WHERE pull = 1;";

    SRC_SIZE_TOTAL="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to get size total from TMP_DB.\n  SRC_SIZE_TOTAL: '${SRC_SIZE_TOTAL}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";
    [ -z "${SRC_SIZE_TOTAL}" ] && _err "Failed to get size total from TMP_DB.\n  SRC_SIZE_TOTAL: '${SRC_SIZE_TOTAL}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_setSrcSizePulled() {

    local query="SELECT SUM(size) FROM ${TABLE_SRC_DIRS} WHERE pulled = 1;";

    SRC_SIZE_PULLED="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to get size done from TMP_DB.\n  SRC_SIZE_PULLED: '${SRC_SIZE_PULLED}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    [ -z "${SRC_SIZE_PULLED}" ] && SRC_SIZE_PULLED=0;

    return 0;
};

_dbFetchNames() {

    local query="SELECT name FROM ${TABLE_SRC_DIRS} WHERE pulled = 0 AND pull = 1 ORDER BY sort, size ASC;";

    IFS=$'\r\n' read -d '' -r -a SRC_NAMES < <(sqlite3 "${TMP_DB}" "${query}");
    [ -z "${SRC_NAMES[*]}" ] && _err "Failed to populate SRC_NAMES array from TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

# Pull each file from the device.
_pullDirs() {
    local name;
    for name in "${SRC_NAMES[@]}"; do
        _pullDir "${name}";
        _c blue "echo Progress: ${SRC_SIZE_PULLED} KB / ${SRC_SIZE_TOTAL} KB $(_percentDone)%";
    done;
};

_pullDir() {

    local name="${*}";

    if _c green "echo -n ==\> Pull \\\"${name}\\\"?" && _Yn 3; then #yes
        "${CMD_PULL}" "${SRC_PARENT}/${name}" &&
            _dbPulled "${name}" &&
            _updateSizeDone "${name}";

    elif _c green "echo -n ==\> Remove \\\"${name}\\\" from backup list?" && _yN 30; then #yes
        _dbDisable "${name}" &&
            _updateSizeDone "${name}";

    else
        _dbSkipped "${name}";
            _updateSizeDone "${name}";

    fi;

    return $?;
};

_dbPulled() {

    local name="${1}";
    local query="UPDATE ${TABLE_SRC_DIRS} SET pulled = 1 WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as pulled in TMP_DB.\n  name: '${name}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_dbSkipped() {

    local name="${1}";
    local query="UPDATE ${TABLE_SRC_DIRS} SET skipped = 1, sort = 0 WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as skipped in TMP_DB.\n  name: '${name}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_dbDisable() {

    local name="${1}";
    local query="UPDATE ${TABLE_SRC_DIRS} SET pull = 0 WHERE name = '${name}';";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to mark row as not to be pulled in TMP_DB.\n  name: '${name}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

_updateSizeDone() {

    local name="${1}";
    local query="SELECT size FROM ${TABLE_SRC_DIRS} WHERE name = '${name}';";
    local size;

    size="$(sqlite3 "${TMP_DB}" "${query}")";
    [ $? -ne 0 ] && _err "Failed to get size from TMP_DB.\n  name: '${name}'\n  size: '${size}'\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    SRC_SIZE_PULLED=$((SRC_SIZE_PULLED + size));
};

_percentDone() {
    node -p "parseFloat(${SRC_SIZE_PULLED} / ${SRC_SIZE_TOTAL} / 100).toFixed(2)";
};

# Manage temporary files and report any final errors.
_cleanUp() {

    [ -e "${TMP_FILE_DIRS}" ] && "${CMD_RM}" "${TMP_FILE_DIRS}";

    echo;
    echo "Did not pull:";
    _dbFetchNonPulled;

    if (_c green "echo -n ==\> Pull them now?" && _yN); then #yes
        "$0";
        exit $?;
    fi;

    if (_c green "echo -n ==\> Remember to pull these files the next time this script is run?" && _Yn); then #yes
        return 0;
    else
        [ -e "${TMP_DB}" ] && "${CMD_RM}" "${TMP_DB}";
    fi;
};

_dbFetchNonPulled() {

    local query="SELECT name FROM ${TABLE_SRC_DIRS} WHERE pulled = 0;";

    sqlite3 "${TMP_DB}" "${query}";
    [ $? -ne 0 ] && _err "Failed to fetch non-pulled rows from TMP_DB.\n  TMP_DB: '${TMP_DB}'\n  query: '${query}'";

    return 0;
};

# Set console color.
# Optionally, run a command afterwards, and once the command returns,
#   reset the console color to normal.
_c() {
    local -A Codes=(
        ["black"]="0"
        ["red"]="1"
        ["green"]="2"
        ["yellow"]="3"
        ["blue"]="4"
        ["magenta"]="5"
        ["cyan"]="6"
        ["white"]="7"
        ["bk"]="0"
        ["r"]="1"
        ["g"]="2"
        ["y"]="3"
        ["bu"]="4"
        ["m"]="5"
        ["c"]="6"
        ["w"]="7"
    );

    local k c;
    for k in "${!Codes[@]}"; do
        [ "${k}" = "${1}" ] &&
            c="${Codes[$k]}";
    done;

    [ -n "${c}" ] &&
        tput setaf "${c}";

    [ -z "${*:2}" ] &&
        return;
    eval "${@:2}";
    tput sgr0;
};

# Set the console color to bold.
# Optionally, pass any arguments to function '_c'.
_C() {
    tput bold;
    [ -n "$*" ] &&
        _c "$@";
};

# Reset console color to normal.
_u() {
    tput sgr0;
};

# Echo a command, and then evaluate it.
_evalcho() {
    echo "$@";
    eval "$@";
};

# Exit with status 1 after echoing an error message.
_err() {
    local err="$*";
    [ -z "${err}" ] &&
        err="An error occurred. Cannot continue.";

    _c red;
    echo -e "${err}";
    _u;
    exit 1;
};

# Run a command silently.
_q() {
    eval "$@" >&/dev/null;
};

# Ask user to answer a "yes or no" question.
# Analyse the user's answer, with NO as the default.
_yN() {
    local -i t="${1}";
    local ans;

    if [ "${t}" != 0 ]; then
        read -t "${t}" -p "${*:2} [y/N]: " ans;
    else
        read -p "$* [y/N]: " ans;
    fi;

    [ -z "${ans}" ] && echo;

    case "${ans}" in [yY] | [yY][eE][sS])
        return 0;
    esac;
    return 1;
};

# Ask user to answer a "yes or no" question.
# Analyse the user's answer, with YES as the default.
_Yn() {
    local -i t="${1}";
    local ans;

    if [ "${t}" = 0 ]; then
        read -p "$* [Y/n]: " ans;
    else
        read -t "${t}" -p "${*:2} [Y/n]: " ans;
    fi;

    [ -z "${ans}" ] && echo;

    case "${ans}" in [nN] | [nN][oO])
        return 1;
    esac;
    return 0;
};

# Remove a trailing '/' from a string if it exists.
_trimEndSlash() {
    local d="$*";
    if [ "${d: -1}" = "/" ]; then
        echo "${d:: -1}";
    else
        echo "${d}";
    fi;
};

_init "$@";
_main || exit $?;
